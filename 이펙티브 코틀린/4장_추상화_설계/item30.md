# item 30 요소의 가시성을 최소화하라

가시성 이야기를 하는데 사실 뭐 코틀린만의 이야기가 아니라 객체지향을 사용한다면 모두 따라야하는 캡슐화를 이야기하고있다.  

객체의 설계 규칙을 잘지켰는가? 이 내용을 계속해서 객체지향의 키워드가 아닌 다른 키워드를 이용해서 설명하려한다.  
그래서 item 내에서 나온 문장들에 대해 객체지향적으로 주석을 달아보려한다.

### 기능이 많은 클래스보다 적은 클래스를 이애하는것이 쉽습니다.

당연한 이야기다.   
애초에 외부 인터페이스가 너무 많으면 객체가 너무 많은 책임을지고 있는지부터 고민하는게 객체지향을 다루는 사람들의 기본 자세아닌가?  

클래스를 이해하고 사용하며 유지보수 하는데도 쉽고 중요하지만  
객체지향에서는 god object를 지양하고 객체에 적당한 책임을 분배하는 설계를 연습한다면 자동으로 해결될 문제같다.  

### 변경에 관한 내용(공개 API -> 가시성 변경시 라이브러리 사용자 분노, 해당 API 사용하던 클래스 모두 수정이 요구됨)

이건 캡슐화에 관한 이야기이다.  
이것또한 당연히 고려될 항목이다 그냥 뭐하러 지금 이렇게 구구절절 정리하나 싶긴한데 캡슐화만 잘되어있어도 유지보수성이 엄청 올라갈것이다.

상황이 정확히 맞아 들어가지는 않을수 있지만(애초에 공개 API로 잘 설계되었지만 시대의 흐름을 타고 수정하는 상황)  
구글에서 API들 수정하는거 보면 정말 구글 개발자들 고통스러움이 눈에 보인다.  
애초에 엄청 옛날에 설계된 API 1부터 있던것들 deprecated 시키지만 계속 사용은 할수있게 냅둬야하고   
이거 실제로 제거할때는 매년 연례행사처럼 하는 안드로이드버전 대응 문서에다가 구구절절히 왜 이거 없애야하는지, 어떻게 없애야하는지 열심히 안내해야한다.  

공개 API의 수정은 이만큼 어렵다.  
특히나 일반적으로 우리 프로젝트에나 적용되는 쪼꼬만한 코드가 아닌 대기업에 SDK 팀에만 들어가도 어려울테고  
내가 혹여나 구글 안드로이드 만드는 개발자가 된다면 더더더더더더욱 어려울거다.  

근데 구태여 숨길수있는 API들을 공개로 다 까발릴 필요가 있는가?  
접근제한자 실수로 안붙여서 숨겨지지 않은 API들을 다른 개발자들이 잘쓰고있다가 갑자기 숨겨버리면   
이제 개 화난 개발자들이 레포지토리에 욕박으러 찾아올것이다.  

### 프로퍼티 외부에서 변경하도록 허용

이것도 캡슐화다.  
진짜 당연한 이야기 아닌가?   

이건 너무 기초적이라 굳이 설명도 필요없고 그냥 풀어놓는거 자체가 에러다.

단순한 setter지양은 당연하고(물론 100%는 어려울수 있지만)  
"메서드의 시그니처를 통해서 상태값 변경을 예상할 수 있는가? " 이런 문제들을 고민 해봐야한다.

번외: 동시성 문제 나오는데 이게 오히려 중요하다.  
객체는 시간에 따라 변동되는 상태를 가지고있는데 이 상태를 외부에서 컨트롤 할 수 없다면 그나마 동시성 문제에서 자유로워 질 수 있다.  
(이거 지킨다고 동시성 문제가 다 해결되는것도 아님)

물론 명령형 언어에서 동시성 문제는 항상 경계해야하지만 객체의 상태를 외부에서 컨트롤할 수 없고 객체가 조건에 맞춰 알아서 상태를 컨트롤하고  
관련된 기능을 수행한다면 동시성 문제의 범위를 객체 내부에서만 바라볼수 있도록 범위 조정이 가능하다.  

하지만 외부에서 상태를 맘대로 조정이 가능하다?  
-> 그냥 막 다른스레드가 와서 내 객체 다 변경시키고가면 디버깅도 안되고 그냥 동시성문제도 빠방빵 터지고 난리버거지 나는거다.  

<details>
<summary>참고: 명형형 vs 선언형</summary>


**명령형(Imperative)** — 상위 개념

- 절차형(Procedural) — C 같은
- 객체지향(OOP) — Java, Kotlin 같은

**선언형(Declarative)** — 상위 개념

- 함수형(Functional) — Haskell, Erlang 같은

</details>

### 가시성 한정자 사용하기

코틀린 가시성 한정자 나오는데 뭐 다아는 이야기일테니 넘어간다.(기억안나면 검색해)




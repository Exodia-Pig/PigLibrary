# 7장 동기화 예제

예제를 다루는 장이다 6장에서 학습한 내용에 대한것들을 고전적으로 발생하는 문제들에 어떻게 적용해서 풀지,  
각 운영체제나 런타임에서는 어떻게 사용하는지 살펴본다.

## 고전적인 동기화 문제
그냥 학습용이자 새로운 동기화 해결방법이 나왔을때 잘 짜여졌는지 검증할수있는 수문장 역할이다.  
학습을 위해 다시 둘러보자

### 유한 버퍼문제
기록할 만한게 없다 그냥 뭔가 문제가 생겼다면 와서 책다시 읽자  

### Readers-Writers 문제
여러곳에서 동시에 읽는건 문제 발생 안함  
쓰기와 쓰기, 쓰기와 읽기가 동시에 일어나면 문제 발생  
그래서 쓸때 자원획득을 해서 쓰도록 조치하는 문제이다.  

책에서 이런것들을 고려할때 문제점이 발생한다는데 말을 뒤지게 못한다.

첫번째 문제
요약: “읽는 애들이 많을 때, 쓰는 애는 언제 들어갈 수 있나?”
- 👉 Reader를 최대한 우대
  - Reader는 서로 절대 막지 않음
  - Writer는 Reader가 모두 끝난 뒤에만 접근 가능
- 특징
  - 여러 Reader 동시 접근 허용
  - Writer는 Reader가 하나라도 있으면 대기
  - 새로운 Reader가 계속 들어오면? Writer 기아현상 발생 가능성있음

두번째 문제
요약: “Writer가 기다리고 있으면, Reader를 계속 들여보내도 되나?”
- 👉 Writer를 우대
  - Writer가 대기 중이면
  - 새로운 Reader 진입 금지
- 특징
  - Writer가 기다리기 시작한 순간 이후 Reader는 전부 block
  - 기존 Reader만 끝나면 Writer 바로 실행
  - 이번엔 reader 기아현상 발생가능(writer 계속 들어옴)

그리고 책에서 문제가 있다고 해놓고 해결법을 말안하고 뭔 부록에 있다고하고 다음에 본다고하고  
뭔말이 하고싶은지 모르겠으나 일단 gpt와 이문제 어떻게 해결하는 변형이 있는지 살펴봤다.

걍 들어온 순서대로 처리하는 FIFO 큐로 처리한단다.
>“Reader / Writer 요청을 하나의 큐에 넣고, 들어온 순서(FIFO)를 기준으로 접근 권한을 부여한다.”
근데 gpt한테 답변듣기전에도 아니 순서대로 처리하면되자나 비효울적인가? 이 생각을 계속하고 있었는데 역시 사람생각은 똑같다.

뭐 다른 변형으로 문제점들을 해결하는 방법이 많겠지만 일반적으로 FIFO 큐로 해결한다고 한다.

### 식사하는 철학자
자 맨날 나오는거 나왔다 그냥 맘같아서는 수저도 못집는 놈들은 도태되는게 당연한거 아닌가?  
자연의 알고리즘을 무시하는 행위라는 생각이 스멀스멀 올라오지만(이래서 격투기를 배워야함 수저를 뻇겠다는 마인드) 일단 살펴보면  

책의 예시는 세마포랑 모니터로 데드락이 안일어나지만 스타빙은 일어날 수 있는 해결책을 보여준다.  
근데 솔직히 모니터 예제는 c로 보면 머리통이 터져서 gpt한테 각예시 코틀린으로 들어달라했다.  
뭐 쩃든 이걸보고 이해하는게 나은거같다.

<details>
<summary>코틀린 모니터 예제 구현</summary>

```kotlin
import kotlin.random.Random

private enum class State { THINKING, HUNGRY, EATING }

/**
 * Dining Philosophers Monitor
 *
 * - 단 하나의 모니터(이 객체의 intrinsic lock)로 모든 상태를 관리합니다.
 * - pickup(): HUNGRY로 바꾸고, 양 옆이 EATING이 아니면 EATING으로 전환.
 *            아니면 wait()로 잠들었다가 누군가 putdown()에서 notifyAll() 하면 다시 검사.
 * - putdown(): THINKING으로 바꾸고 notifyAll()로 모두 깨워 재검사 유도.
 *
 * 이 구조는 "젓가락을 하나씩 들다가 교착" 같은 deadlock을 원천 차단합니다.
 */
class DiningPhilosophersMonitor(
    private val n: Int
) {
    private val state = Array(n) { State.THINKING }

    private fun left(i: Int) = (i + n - 1) % n
    private fun right(i: Int) = (i + 1) % n

    /** i가 지금 먹어도 되는지(양 옆이 먹는 중이 아닌지) 검사 */
    private fun canEat(i: Int): Boolean {
        return state[i] == State.HUNGRY &&
                state[left(i)] != State.EATING &&
                state[right(i)] != State.EATING
    }

    /**
     * 젓가락 집기(= 먹기 시작 요청)
     * - 모니터 진입 후 상태를 HUNGRY로 만들고
     * - 먹을 수 있을 때까지 while 루프로 조건을 재검사하며 wait()
     */
    fun pickup(i: Int) {
        synchronized(this) {
            state[i] = State.HUNGRY

            // spurious wakeup 방지: 반드시 while 로 조건 재검사
            while (!canEat(i)) {
                // 누군가 putdown()에서 notifyAll() 해주면 깨어나서 다시 검사
                wait()
            }

            state[i] = State.EATING
        }
    }

    /**
     * 젓가락 내려놓기(= 먹기 종료)
     * - 상태를 THINKING으로 바꾸고
     * - 주변 철학자들이 먹을 수 있을지 다시 검사하도록 notifyAll()
     */
    fun putdown(i: Int) {
        synchronized(this) {
            state[i] = State.THINKING
            notifyAll()
        }
    }
}

/** 철학자 스레드 */
class Philosopher(
    private val id: Int,
    private val monitor: DiningPhilosophersMonitor,
    private val random: Random = Random(id)
) : Thread("Philosopher-$id") {

    override fun run() {
        repeat(30) { round ->
            think(round)
            monitor.pickup(id)
            try {
                eat(round)
            } finally {
                monitor.putdown(id)
            }
        }
    }

    private fun think(round: Int) {
        // 생각(랜덤 sleep)
        Thread.sleep(random.nextLong(10L, 80L))
    }

    private fun eat(round: Int) {
        // 먹기(랜덤 sleep)
        Thread.sleep(random.nextLong(10L, 60L))
    }
}

fun main() {
    val n = 5
    val monitor = DiningPhilosophersMonitor(n)

    val philosophers = (0 until n).map { Philosopher(it, monitor) }
    philosophers.forEach { it.start() }

    // 간단 모니터링(상태 출력)
    repeat(40) {
        Thread.sleep(100)
        println("state = ${monitor.snapshot()}")
    }

    philosophers.forEach { it.join() }
    println("done")
}
```

이 방식이 “모니터로 해결”인 이유와 동작 포인트
- 공유 자원(젓가락)을 개별 락으로 쪼개지 않고, “먹을 수 있는지”를 상태 머신으로 표현합니다.
- pickup()은
  1. HUNGRY로 표시
  2. while (!canEat(i)) wait() 로 조건이 만족될 때까지 잠듦
  3. 조건 만족 시 EATING으로 전환
- putdown()은
  1. THINKING으로 복귀
  2. notifyAll()로 잠든 스레드들을 깨워 “이제 먹을 수 있는 사람 있나?”를 재검사하게 함
- while을 쓰는 이유: JVM의 wait()는 spurious wakeup(이유 없이 깨어남)이 가능하므로, 깨어나면 조건을 다시 검사해야 안전합니다.

</details>

## 커널 안에서의 동기화
### windows의 예시
솔직히 그냥 읽고 넘어가는거지 그닥 공감가지 않는다.  
내부적으로 스핀락을 짧은 락을 컨트롤하는데 사용하고 스린락을 도는동안 선점되지 않게 관리한다고 한다.  

또한 Dispatcherr객체를 제공하는데  
Mutex, Semaphore, Event, Timer 이런것들을 커널에서 객체로 제공한단다.
그래서 뭐 각 대기큐가 있고 뭐 객체로 어쩌구 저쩌구 관리한다는데 내용이 애매해서 딱히의미 없다.

### Linux의 예시
솔직히 별로 필요없다.  
OS의 대략적인 구현이야기 원자적변수 사용하고 락기법들 다 앞쪽에서 이야기한것들인데 그원리를 이해만하면되지 딱히 리눅스에서 뭘썼는지는 내가 알고싶은 영역 밖인것 같다.

### POSIX의 예시
이거는 그나마 커널이야기가 아니라 우리같은 응용프로그래머가 사용하는 락 관련 api이야기인데 이또한 딱히 의미없었다.  
나는 POSIX 환경에서 개발하고 있지 않고 책에서 그냥 단순히 api를 나열하고있어서 그냥 흐음 하고 봤다.  
기명 세마포, 무기명 세마포가 있긴한데 뭐 이것도 다들 어떤개념인지 한방에 와닿을거다.(프래그먼트에 태그붙여서 찾는느낌)

### Java의 예시 
이제 나의 언어 자바가 나온다 히히히히히히히 이제 열심히 봐야지  
#### Java 모니터
Bounded Buffer 예시를 보면서 살펴봐야할 포인트는 2가지인것 같다.
1. 자바에서의 모니터 구현(Synchronized)
2. wait,notify(notifyAll)을 통한 락 및 cpu제어권 뻇어서 비용절감한 대기   

차례대로 살펴보자  

##### [ 자바에서 모니터 구현 ]  
자바는 기본적으로 모니터 자체가 객체에 녹아들어가 있다.  
-> 그렇다고 object이런데  필드로 구현 되어있는건 아니고(필요사항 ex.entry set, lock 이런거 jvm 네이티브 영역에서 구현되어 있음) 그냥 자바언어 자체의 설계라고 보는것이 맞다.

그래서 객체라면 기본적으로 Lock을 하나씩 들고있고 이런 락들을 syncronized 문법을 어떻게 써먹냐에 따라 누구의 락을 가지고   블록이나 함수를 처리할건지 결정하게 해준다.(자바는 모든걸 객체로 박아놔서 사실상 뭘 가지고 접근해도 락이있는 형태)  
참고: 락은 실제로 필요한 시점에 생성됨(싱크로나이즈 이딴거 안만나면 애초에 생성조차 안됨 jvm 내부에서)  

그래서 각 객체마다 lock을 받기위에 대기하는 entry set도 내부에 존재한다(이것도 jvm 네이티브 영역).  
그래서 락을 잡기위해서 대기하고 순서 받아서 접근하고 이런 과정이 오는데 이때 락 획득 순서는 확정적 자바 사양으로 정의된건 없고 그냥 왠만해서 FIFO라고 책에 나온다(근데 알바아님)  

이제 그럼 synchronized 메서드 문법은 [다음 페이지](synchronized.md)를 참고하자

##### [ wait,notify(notifyAll)을 통한 락 및 cpu제어권 뻇어서 비용절감한 대기 ]
wait/notify를 이용해서 대기큐를 구성하는 내용을 보여주는데 이게 단순 bounded buffer를 구현하는데만 쓰이는게 아니라  
락을 효율적으로 이용하기 위한 일반적인 방법이라 자세히 학습을 해보았다.

내가 이해한 바를 간단하게 정리하면 다음과 같다.  

프로그램은 다음흐름으로 진행된다.
1. Lock을 얻음
2. 프로그램 내부에서 조건을 검사해서 실행할수있는지 확인함
3. 조건이 만족되지못해서 실행을 못함

이럴떄 다른스레드가 락을 잡고 어떤 행위를 수행해서 실행 조건을 만들어줄수도 있을 수 있고 -> 이때 계속 잡고있으면 데드락임  
그게 아니더라도 스레드가 계속 락을 잡고있는건 비효율적이니 놔야한다.

그래서 그때 락을 놓고 재우는 방법을 제공하는게 wait/notify다.

그래서 클로드와 gpt를 패서 [관련 md파일](./wait-notify.md) 하나 구성했다. 이걸 읽어보자

#### 재진입락 Reentrant Locks
Synchronized랑 책 설명상으로는 별 다를바 없어보이는데 사실상 안정적으로 lock을 사용할 수 있도록 많은 기능들을 제공한다.  
그래서 이것도 claude랑 질답하면서 하나하나 [자료](./reentrant-locks.md.md)로 생성해봤다.   

근데 실상 이거정리하면서 느낀게 이 모든 java api는 코틀린에서 애매할수도 있는게 thread 기반이다.   
또한 코틀린에서는 코루틴 기반 동시성 기능들을 제공하기 떄문에 우리는 요즘 대부분 코루틴을 쓰고 코루틴 기반 락을 써야할것 같다.  

그래서 재진입 락도 코루틴 기반 Mutex,channel(Bounded buffer 대체)로 대체가 가능하다  

#### 세마포 Semaphores
걍 자바에서 세마포 제공한다는 이야기한다.  
-> 코루틴 세마포가 따로 존재한다.

#### 조건변수 Condition Variables
[재진입락 정리문서](./reentrant-locks.md.md)에 엄청 자세히 정리되어있다.  
그냥 그거보면됨

### 대체 방안들
다중 코어 환경에서 병행 프로그래밍이 요구되었고 여태까지 본 락종류들이 활용되었지만  
이를 제외하고도 다른 방법들도 제시되었다고한다.  
그 방법들을 살펴보자(프로그래밍 언어, 하드웨어)  

#### 트렌잭션 메모리
DB이론 분야에서 써먹는개념인데 병행 프로그래밍을 위한 방법으로 제시가 되었다고 한다.  
근데 이론적일뿐 사용은 실질적으로 하고있지않은 방법이라고 한다.  
그래서 걍 재미로만 읽으면 될것 같다.(대충 알아두는거지)

- 소프트웨어 TM (STM)
  - Haskell STM (유일하게 실사용됨) -> 순수 함수형 언어라 가능하다 한다.
  - jvm 계통에서는 거의 사용되지 않는다고 한다.(기존 구조와 충돌이 이유)
- 하드웨어 TM (HTM)
  -  Intel TSX (Transactional Synchronization Extensions) -> Haswell 이후 일부 CPU 적용
  -  여러 문제가 있어서 도태되었다고 한다.

#### OpenMP
내가 4장을 시간이 없어서 안읽고 지나가서 4장에서 OpenMP를 잘모른다.  
근데 대략 찾아보니 C,C++,포트란 에서만 사용되고 C언어계통(러스트, go, swift)에서도 안쓰는 방식이란다.  
아직 C같이 성능위주의 언어에서는 쓰이는것 같으나 지금 JVM 계열에서만 놀고있는 나는 사실상 필요없으니  
더욱더 지식을 탐닉하고싶을때 봐야겠다.

#### 함수형 프로그래밍 언어
-> 이거야말로 사실 이 단원에서 제일 어려운것 같다.  

[절차형]  
c, c++, java 이런언어들은 명령형(절자형) 언어인데 상태기반의 알고리즘을 구현하는데 사용된다고 한다.  
상태는 시간의 흐름에 따라 변경되고 즉 시간이 상태를 결정하는 주요 요소이다.  


[함수형]  
반면 함수형 프로그래밍은 절차형과는 패러다임 자체가 다르다.  

함수형에서는 상태를 내부에 유지하지 않는 방식을 지향하며,  
변수는 기본적으로 불변(immutable)으로 취급된다.  

이로 인해 다음과 같은 특징이 나타난다.  
- 외부 공유 상태를 두지 않음
- 상태 변경 대신 값의 변환을 사용
- 여러 스레드가 동시에 접근할 대상 자체가 없음

그래서 교착상태나 경쟁 조건과 같은 동시성 문제가  
구조적으로 발생하지 않도록 설계된다.  

>“외부 값을 두 스레드가 동시에 접근하는데  
>애초에 외부 값 자체가 없다”는 표현이 이해에 도움이 되었다.  

[간단한 예시]

🤼‍♀️명령형
```kotlin
var balance = 1000   // ❗ 외부 상태 (공유 가변 상태)

fun withdraw(amount: Int) {
    balance -= amount
}

// Thread A
withdraw(100)

// Thread B
withdraw(100)

-> 결과 이상해질수 있음
```
-> 여러 스레드에서 하나의 상태 접근(임계구역문제 생김)

문제점
- balance는 함수 외부에 존재
- 여러 스레드가 동시에 접근 가능


💪함수형
```kotlin
fun withdraw(balance: Int, amount: Int): Int {
    return balance - amount
}

val result1 = withdraw(1000, 100)
val result2 = withdraw(1000, 100)
```

애초에 개발하는 방식자체가
외부상태❌, 공유상태❌, 불변 을 사용하기 떄문에 동시성이 날게 없다.
-> 애초에 각각 연산되어서 각각에 담기는데 뭔동시성인가

근데 이런 패러다임으로 개발하는 방식자체를 아직 잘못하고 이해도도 낮다.  
그래서 함수형을 공부해서 동시성 문제가 발생하는데서 함수형 패러다임의 철학이 녹아있는 코드를짜면 좋은것 같다.  
나중에 혼자 그 코틀린 아카데미 함수형 읽을라 했는데 그때 동시성문제가 없는게 맞는지 확인하면서 읽어야겠다.  

결론 함수형 책읽고 공부해보자  

-> 근데 희안하에 함수형이 메인 패러다임인 언어는 다 죽어버린것 같다.(이유가 뭐지?)  
gpt한테 물어보니까 결국 학습곡선이 너무 높아서 그냥 좋은 부분만 추출하자 관점으로 갔다고 한다.  
아직 우리한테는 너무 장벽이 높은거지 ㅋㅋ  
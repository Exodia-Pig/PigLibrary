# CPU 스케쥴링

### 왜 cpu 스케쥴링을 진행하는가?
cpu 사용의 효율을 극대화 하기위해 -> I/O 등으로 cpu가 쉬는것을 방지

### cpu-I/O 버스트
프로세스는 두가지 상태를 가진다
- cpu burst
- I/O burst

프로세스는 이 두 버스트가 지속적으로 교대되며 구성된다.  
일반적으로 cpu버스트는 하기 이미지와 같이 짧은 버스트 시간이 일반적이다.  
 ![](./res/cpu%20버스트%20히스토그램.png)

 I/O 중심의 일반적인 프로그램 혹은 CPU소모가 큰 프로그램에 따라  
 스케쥴링 알고리즘을 결정하는데 중요한 키가 될수 있다.

 ### CPU 스케쥴러
 다음 cpu 점유권을 소유하는 프로세스는 CPU 스케쥴러에 의해 결정되고  
 ready 상태의 프로세스(PCB) 중 선택된다.  

 ready 큐는 -> fifo, 우선순위, 트리, 순서없는 연결리스트 등 알고리즘에 따라 다양하게 구성될수 있다.  

### 선점형 비선점형
책에서는 다음과 같은 경우 CPU 스케줄링이 일어난다고 명시한다  
1. 한 프로세스가 실행상태에서 대기상태로 전환될떄(I/O,자식 프로세스 wait)
2. 프로세스가 실행상태에서 준비완료 상태로 전환(인터럽트)
3. 프로세스 대기상태에서 준비완료 상태로 전환(I/O종료)
4. 프로세스 종료
   
이떄 1,4 같은경우 프로세스를 바꿀수밖에 없는 상황이고 해당 경우에만 스케쥴링이 일어나는 경우를  
비선점형 1,2,3,4 모든 경우에서 일어나는경우 선점형이라고 한다고 설명한다.  

근데 개인적으로 잘 안와닿고 그냥 이렇게 인지하고있다.  
- 선점형: cpu가 돌아가고있는데 운체가 그냥 뻇어버릴수 있음  
- 비선점형: cpu가 연속적으로 돌아가는 상황이면 못뻇음  

예시로 코틀린 코루틴을 비선점형이라고 하는거고 while문 돌려놓으면 suspend 지점 만날때까지 스레드가 그 코루틴한테 먹힌다  

-> 최신 운체는 선점형을 거의 사용한다고 한다(UNIX,Linux,window,mac os)  

✅체크포인트
- 선점형이라면 공유되는 자료에 레이싱 컨디션이 발생할 수 있다.(6장에 재등장)
- 선점/비선점은 커널 설계에도 영향을 끼친다.
  - 커널 자료도 공유 데이터의 차원으로 봐야하니 racing condition 걸릴수 있다.
- 운영체제 커널 또한 선점형 비선점형으로 설계될 수 있다.
  - 비선점형: 컨텍스트 스위칭 전 시스템콜 혹은 입출력 완료하여 프로세스가 대기상태로 가기를 기다린다.
    - 레이싱 컨디션이 걸리지않아 커널 구조가 단순해도 된다.
    - 실시간 시스템이 부적합하다.
  - 선점형: 시스템콜 이런거 중간에 컨텍스트 스위칭 일어날 수 있음
    - 공유 커널 데이터 구조에 엑세스시 racing condition 방지를 위해 mutex 등 방어수단을 갖춰야한다.
    - 인터럽트는 언제든 발생가능하기 떄문에 인터럽트에 영향을 받는 코드라면 동시사용으로부터 보호되어야한다.(보호 하지 않을시 입력이 씹히거나 출력이 중복될수 있다.)
    - 이런 문제되는 코드는 여러 프로세스가 접근할 수 없도록 해당 코드 시작점에서 인터럽트 불능화,코드가 끝났을떄 인터럽트 활성화 시킨다고한다(자주 발생 하면안되고 아주 일부 명령어만)

### 디스패처
CPU 코어 제어권을 실제로 넘겨주는 모듈

- 프로세스간 컨텍스트 스위칭
- 사용자모드로 전환
- 프로그랭 다시 시작하기위해 사용자 프로그램의 어떤위치로 jump 

이 세가지 작업을 한다고 한다.  
-> 그래서 프로세스 정지시키고 다른 프로세스로 갈아끼우는 지연을 디스패처 지연이라고 한다.

### 스케쥴링 기준
스케줄링 알고리즘에 대한 기준은 다음과 같다.(평가요소 느낌)
- cpu 이용율
- 처리량(일정시간 동안 완료된 프로세스 수)
- 총 처리 시간(한 프로세스가 끝나는데 걸리는 모든걸 더한 시간)
- 대기 시간(프로세스가 대기한 시간을 총합)
- 응답시간

## CPU 스케쥴링 알고리즘
해당 책에서는 설명을 위해서 싱글 코어로 가정하고 설명한다고 한다.

### 선인선출 스케줄링
구현: FIFO큐로 단순 구현하면됨  
딱봐도 문제점이 많다.   
- cpu 바운드 프로세스가 앞에 존재시 평균 대기시간 증가
- 호위 효과(다른 모든 프로세스가 cpu사용량이 긴 프로세스를 기다리는 형태) -> cpu 장치이용율 저하
- 비선점형

### 최단작업 우선 스케줄링(SJF)
큐에 있는 프로세스들에 CPU 버스트를 계산해서 최단 CPU 버스트를 가진 프로세스부터 우선적으로 CPU를 배정  
-> CPU 버스트 시간을 계산할 수 없기에 기존 CPU 점유시간을 기반으로 지수평균으로 구한다.(예상 CPU 버스트 시간)  
선점형/비선점형으로 나뉜다.  
- 선점형: 중간에 프로세스 들어오면 현재 CPU 잡고있는 프로세스 잔여 시간보다 신규 프로세스 버스트시간 짧으면 대체  
- 비선점형: 한번 들어간건 다처리하게 둠  

평균 대기 시간이 짧아지긴 하는데  
책에는 안나오지만 starving 걸려서 긴것들은 다 처리가 잘안될것이다.  

### 라운드 로빈
선점형 서클러큐에 선입선출로 쌓이는데 타이머를 통해서 다음 프로세스한테 cpu 주도권일 일정시간 이후에 준다.  
책에는 안나오지만 starving문제가 해결된다.  

하지만 context switching 비용증가가 있고 한사이클의 시간 조정에 따라서 성능(지표들의 값)이 변화된다.  

### 우선순위 스케쥴링
사실상 SJF가 우선순위의 일종이다 -> 이거 에서 우선순위가 뭐 제멋대로 정해지면 우선순위 스케쥴링이다.  
- starving -> 우선순위 낮아서 영영 못받음
- aging -> 시간이 갈수록 우선순위 증가(starving 해결방법)

라운드 로빈과 합쳐서 사용해서 starving을 방지도 가능하다.  

### 다단계 큐 스케쥴링
큐를 하나로 관리하면 검색비용이 드니까 O(n)  
애초에 큐자체의 우선순위를 두는것이다  
그래서 선점형으로 구성되고 각 큐별로 스케쥴링 알고리즘을 다르게 가져갈 수 있다.  

예시를 들면 이런느낌이다  
1. 실시간 프로세스
2. 시스템 프로세스
3. 대화형 프로세스
4. 배치 프로세스

레이어드 아키텍처 느낌이 난다.  

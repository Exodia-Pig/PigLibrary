## Mutex Lock
실제로 이제 상호배제를 제공하는 도구를 다룬다.  

-> 이게 우리가 생각하는 상호배제를 위한 해결책이다 여태까지 본거는 다 그냥 이걸 하기위한 도구들이였다.

기존 제시된 내용들 원자적 변수, 하드웨어 명령어, 메모리 장벽 이런것들을 이용해서 상호배제를 직접 구현하려면  
너무 품이 많이들고 그야말로 저수준의 내용까지 알아야하니 이걸 운영체제(혹은 언어/런타임 차원)에서 상호배제를 위해 추상화를 시켜주고 그거 쓰게 던져준거다.  

기본 적인 개념은 1개짜리 Lock 을 제공하는것이다.
이를 위해 두가지 연산과 한가지 상태를 가지는데 다음과 같다.
- acquire / Lock 획득연산
- release / Lock 풀어주는 연산
- available / 현재 Lock의 가용여부(상태) -> Private

그래서 이런식으로 구성된다.
```
acquire(){
    while(!available)
        ;/* busy wait */
    available = false;
}
```

```
release(){
    available = true;
}
```

근데 지금 구현방식을 보면 busy wait)을 시킨다.  
-> 책에서 busy wait은 cpu를 그냥 소모시켜 성능을 떨어트릴수 있다고 한다.  

하지만 대기상태로 놓고 다른일을 할때는 context스위칭이 2번 일어나는데 이 비용이 더 클수 있기 때문에  
이 비용과 cpu가 날아가는 비용을 비교했을때 context스위칭 비용이 크다면 그냥 이방법을 택하는게 나을수도 있다고 한다.  
그래서 스핀락이라고도 부르고 다중코어 시스템에서 스핀락을 잘사용하고 있고 널리사용된다고 한다.


사견: 일반적으로 여태까지 학습할때 busy wait은 성능을 겁나 떨어트린다고 생각했는데 운영체제 구현이나 코루틴 구현 그리고 지금과  같은 상황을 봤을때 상황에 따라 사용을 고려해볼수 있는 방법인것 같다.(어태까지 극강의 안티패턴이라 인식)


## 세마포(Semaphores)
### 개념
세마포 잡설 부터 시작한다.  
세마포는 다익스트라가 고안했다고한다 그 다익스트라 알고리즘의 다익스트라다.  

역시 천재라 한가지 족적만 남긴게 아니다.  
다익스트라가 네덜란드인이라 그 연산이 P,V 이렇게 표시하는데(강의 보면 그냥 갑자기 P,V갈김) 네덜란드말 앞글자란다.

세마포어 기본적인 개념은 정수개의 Lock을 제공하는것이고. 
이를 위해 정수값 상태와 2가지 연산을 제공한다.
- wait(P) / Lock 획득 시도
- signal(V) / Lock 놓기
- S / 정수값(lock 갯수 표현)

세마포어 정수값 연산은 원자적으로 수행되어야하고 상호배제도 일어나야하며 wait 연산또한 인터럽트로 중간에 찢어지면 안된다고 하는데
그건 뭐 jvm 에서 제공하는 추상체가 알아서 하겠지 내가 그것까지 골머리 썩을건 아니라고 생각한다.  
물론 알면 좋지만 그렇게 따지면 어셈블리로 코딩하는 벙법부터 공부해야지 괜히 c언어가 나왔겠는가?

### 사용법
이진과 카운팅이 있다는데 이진은 사실상 뮤텍스랑 거의 동치라 보면된다.  
그래서 몇몇 시스템에서는 뮤텍스를 아예 제공하지 않고 이진 세마포어를 쓰는경우가 있다고 한다.  

그냥 우리가 생각하는대로 가용가능 자원갯수로 정수 초기화 자원을 얻고 반환하고 그런식으로 사용을 이야기한다.

사실 요즘 언어에서 이런식으로 안쓰겠지만 세마포어로 명령어 실행순서를 보장하는 방법도 간단하게 나온다.  
그냥 예시는 직접 책에서 보자(중요하지 않은것 같다.)

### 구현
세마포어구현을 설명한다기 보다는 스핀락과 프로세스를 아예 재웠다가(대기상태) 꺠우는 구현을 설명한다.

프로세스 재우는거는 우리가 일반적으로 스레드 sleep 걸어서 대기큐에 넣고 꺠우고 하는거랑 같다.  
그래서 그 연산은 운영체제에서 시스템콜로 sleep,wakeup 연산으로 제공된다.

세마포어 구현체는 정수랑 대기 프로세스 리스트를 가지는데  
대기하는 프로세스 리스트의 경우 PCB 자체의 포인터를 들고있는다고 한다.  
그리고 리스트의 큐잉전략은 뭘써도 상관없다고 한다(선입선출을 예시로듬)  

여기서 부터 구현에 대해 핵심적으로 말하고싶어보이는 내용이 나온다.  
세마포어는 원자적으로 실행되어야하고 두 프로세스가 동시에 연산들을 실행할수 없도록 임계구역 문제를 해결해야하는데  
단일 처리기는 연산의 인터럽트만 금지하면되는데  
다중 코어에서는 인터럽트를 금지하는게 어려울수 있고 성능이 떨어져서 그냥 스핀락을 오히려 사용한다고 한다.(뭐 상황 맞춰서)  
스핀락을 wait/signal 에만 국한해서 사용하고 이거는 대기가 짧아서 상관없다고 한다.  
근데 대기시간이 길면 극도로 비효율 적이 된다고 한다.  

## 모니터
이유 세마포,뮤텍스 줬는데 준대로 안쓰고 휴먼에러를 막 발생시키는 개찐빠들을 위하여 그런것들을 휴먼에러 안나게 추상화해서 제공하는게 모니터다.  
그리고 개찐빠를 욕하지마라 그 개찐빠가 나다.

#### 모니터 사용법
책에서 뭘 말하고싶은건지 아예 이해가 가지않는다. 내가 개찐빠인건지 아님 글을 진짜 못쓰는건지 모르겠는데 걍 모니터는 객체다 이생각밖에 안든다.(실제로 java ,c#에서 모니터 개념을 편입시켰다는거 보면 객체가 맞다)

#### 세마포를 이용한 모니터의 구현, 모니터 내에서 프로세스 수행재게
뭔소리인지 하나도 모르겠다 이거 뭔 그나마 예전에 반효경 교수님강의랑 빗대어서보면 조금이해가는데  
그냥 반효경 교수님 강의 정리로 접근하는게 나을것 같다.  
[관련정리](https://mccoy-devloper.tistory.com/89) 읽어보자. 

애초에 내가 주로 개발하는 환경인 자바/코틀린은 모니터라는 개념을 객체 자체에 녹여놓아서 모니터가 구현된 어떤 실체를 볼 수 없었다.   
그래서 모니터 구현보다는 개념 위주로 가져가는게 맞을것 같다.  

<details>
<summary>자바 코틀린에서의 모니터</summary>

### 자바 / 코틀린에서의 모니터(Monitor) 정리

한 줄 요약

자바와 코틀린에서는 모니터를 직접 다루지 않지만, 실제로는 모든 객체에 모니터가 내장되어 있으며 언어와 런타임 차원에서 자동으로 사용된다.

---

왜 자바 / 코틀린에서는 모니터를 못 본 것처럼 느껴지는가?

운영체제나 교과서에서 말하는 모니터(Monitor)는 다음 요소를 가진다.
- 상호배제(Mutual Exclusion)
- 조건 변수(Condition Variable)
- 자동 락 획득 / 해제 규칙
- wait / signal 메커니즘

하지만 자바는 이 개념을 별도의 Monitor 타입이나 API로 노출하지 않는다.  
대신 “모든 객체가 하나의 모니터를 가진다”는 객체 모델 설계로 흡수했다.

그 결과로 다음과 같은 특징을 가진다.
- Monitor 클래스는 존재하지 않는다
- monitor.lock() 같은 API도 없다
- 객체 + 키워드 + JVM 런타임 동작으로 모니터가 제공된다

그래서 개발자는 모니터를 사용하고 있으면서도 그 존재를 명시적으로 인식하지 못하게 된다.

---

자바에서 모니터는 어디에 숨어 있는가?  

1. synchronized 키워드 = 모니터 진입  
synchronized (lockObject) { } 형태의 코드는 다음 의미를 가진다.
- lockObject가 보유한 모니터를 획득한다 (monitor enter)
- 블록을 벗어나면 모니터를 해제한다 (monitor exit)

이는 교과서에서 말하는 모니터의 진입과 탈출과 정확히 동일하다.

---

2. 모든 객체는 암묵적으로 모니터를 가진다  
자바에서 객체를 하나 생성하면, JVM 내부적으로 해당 객체 전용 모니터가 함께 생성된다.  
이 모니터는 다음 정보를 포함한다.  
- 현재 락을 소유한 스레드(owner)
- 락 획득을 기다리는 스레드 집합(entry set)
- wait() 상태에 들어간 스레드 집합(wait set)

개발자가 이를 직접 접근하거나 확인할 수 없을 뿐, 모니터는 항상 객체와 함께 존재한다.

---

3. wait / notify / notifyAll 은 모니터의 조건 변수  
wait()와 notify()는 일반 메서드처럼 보이지만, 실제로는 모니터와 강하게 결합된 연산이다.  
- wait() 호출 시
- 현재 스레드는 모니터 락을 반납한다
- wait set으로 이동해 대기 상태가 된다
- notify() 호출 시
- wait set에 있는 스레드 하나를 깨운다
- 깨어난 스레드는 다시 락 획득 경쟁에 들어간다

wait()가 반드시 synchronized 블록 내부에서만 호출 가능하도록 제한된 이유도  
모니터 규칙을 강제하기 위함이다.

---

코틀린에서의 모니터  

코틀린은 JVM 위에서 동작하는 언어이기 때문에 자바의 모니터 모델을 그대로 사용한다.  
- synchronized 함수는 JVM의 synchronized와 동일한 바이트코드를 생성한다  
- 새로운 모니터 개념이나 구현을 추가하지 않는다

즉, 코틀린에 모니터가 없는 것이 아니라 자바의 모니터를 그대로 재사용하는 구조다.

---

그런데 왜 요즘은 모니터를 잘 안 쓰는 느낌이 드는가?  

이는 착각이 아니라 실제 개발 흐름의 변화다.  

1. 휴먼 에러 발생 가능성이 높다
- wait / notify 호출 순서 실수
- 조건 검사 누락 (if 대신 while 사용해야 하는 문제)
- notify 와 notifyAll 오용

이런 실수들은 대규모 시스템에서 치명적인 동시성 버그로 이어졌다.

--- 

2. 자바는 더 고수준의 동기화 도구를 제공했다  
그래서 자바는 다음과 같은 추상화된 동기화 도구들을 제공한다.  
- ReentrantLock
- Condition
- Semaphore
- CountDownLatch
- BlockingQueue

이들은 모니터를 직접 다루지 않게 만들기 위한 안전한 추상화 계층이다.  

---

3. 코틀린은 코루틴 기반의 다른 해법을 사용한다  
코틀린 코루틴 환경에서는 보통 다음과 같은 도구를 사용한다.  
- Mutex
- Channel
- Flow
- structured concurrency

이들은 OS 또는 JVM 모니터가 아니라, 논리적 동기화 모델에 가깝다.  

---

정리
- 자바와 코틀린에서도 모니터는 분명히 존재한다
- 다만 객체 모델과 런타임에 완전히 녹아 있어 명시적으로 보이지 않을 뿐이다
- synchronized 와 wait / notify 는 정통적인 모니터 모델의 구현이다
- 현대 개발에서는 더 안전한 고수준 추상화를 사용하는 것이 일반적이다

</details>



### 나머지 부분(라이브니스, 데드락, 우선순위 역전, 평가)
이후에 라이브니스,우선순위 역전, 평가는 딱히 영양가는 없는거 같아서 읽기만했다.  
+ 데드락은 어짜피 8장에서 지겹게 다루니 정리는 생략  